import os
from argparse import ArgumentParser
import numpy as np
from string import ascii_uppercase, ascii_lowercase
import matplotlib.pyplot as plt

from utils import utils


alphabet_list = list(ascii_uppercase+ascii_lowercase)


def plot_ticks(Ls):
    Ln = sum(Ls)
    L_prev = 0
    for L_i in Ls[:-1]:
        L = L_prev + L_i
        L_prev += L_i
        plt.plot([0, Ln], [L, L], color='black')
        plt.plot([L, L], [0, Ln], color='black')
    ticks = np.cumsum([0]+Ls)
    ticks = (ticks[1:] + ticks[:-1])/2
    plt.yticks(ticks, alphabet_list[:len(ticks)])


def plot_pae(pae, Ls=None, dpi=100, fig=True):
    if fig: plt.figure(figsize=(8,5), dpi=dpi)
    plt.title('Predicted Aligned Error')
    Ln = pae.shape[0]
    plt.imshow(pae, cmap='bwr', vmin=0, vmax=30, extent=(0, Ln, Ln, 0))
    if Ls is not None and len(Ls) > 1: plot_ticks(Ls)
    plt.colorbar()
    plt.ylabel('Positions')
    plt.xlabel('Positions')
    return plt


def plot_plddt(plddt, Ls=None, dpi=100, fig=True):
    if fig: plt.figure(figsize=(8,5), dpi=100)
    plt.title('Predicted lDDT per position')
    plt.plot(plddt)
    if Ls is not None:
        L_prev = 0
        for L_i in Ls[:-1]:
            L = L_prev + L_i
            L_prev += L_i
            plt.plot([L, L], [0, 100], color='black')
    plt.ylim(0, 100)
    plt.ylabel('Predicted lDDT')
    plt.xlabel('Positions')
    return plt


def get_chain_lengths(results_dict):
    protein = results_dict['unrelaxed_protein']
    chain_index = protein.chain_index
    residue_index = protein.residue_index
    
    Ls = []
    chain_idx = 0
    for res_idx in range(len(chain_index)):
        if chain_index[res_idx] == chain_idx:
            if len(Ls) < chain_idx + 1:
                Ls.append(0)
        else:
            Ls.append(0)
            chain_idx += 1

        Ls[chain_idx] += 1

    # Double check that we didn't run a monomer model on a multimer.
    if len(Ls) == 1:
        # We ran a monomer.
        if residue_index[-1] == len(residue_index):
            pass
        # We ran a multimer.
        else:
            # Create new container.
            Ls = []

            # Determine where chain breaks occur.
            chain_breaks = []
            adder = 0
            x = iter(range(len(residue_index)))
            for res_idx in range(len(residue_index)):
                differ = abs(next(x) + 1 + adder - residue_index[res_idx])
                if differ != 0:
                    adder += differ
                    chain_breaks.append(res_idx)

            # Determine chain lengths.
            remainder = len(residue_index)
            for breaks in chain_breaks:
                if remainder >= 0:
                    Ls.append(breaks)
                    remainder -= breaks
            if remainder >= 0:
                Ls.append(remainder)

    return Ls


if __name__ == '__main__':

    parser = ArgumentParser()
    parser.add_argument('--input_dir',
                        type=str, default='.',
                        help='Directory which contains .pkl or zipped .pbz2 '
                        'files generated by running AF. Default is "./".')
    parser.add_argument('--output_dir',
                        type=str,
                        default='.',
                        help='Directory where figures will be outputted. '
                        'Default is "./".')
    args = parser.parse_args()

    onlyfiles = [f for f in os.listdir(args.input_dir) if os.path.isfile(
        os.path.join(args.input_dir, f))]

    files = {}
    for filename in onlyfiles:
        extension = filename.split('.')[-1]

        if extension in ['pkl', 'pbz2']:
            if extension not in files:
                files[extension] = []
            files[extension].append( (args.input_dir, filename) )

    if len(files) == 0:
        raise ValueError(
            f'No input files (.pkl or .pbz2) detected in {input_dir}.')
    
    # Run through all saved metrics.
    for extension, file_list in files.items():
        for input_dir, filename in file_list:
            # Skip the timings output if it exists.
            if filename == 'timing.pbz2':
                continue
            elif filename == 'timing.pkl':
                continue
            
            full_filename = os.path.join(input_dir, filename)
            file_stem = ''.join(filename.split('.')[:-1])
        
            if extension == 'pkl':
                result = utils.loosen(full_filename)
            elif extension == 'pbz2':
                result = utils.decompress_pickle(full_filename)

            # Get figure filenames.
            pae_png = os.path.join(args.output_dir, file_stem + '_pae.png')
            plddt_png = os.path.join(args.output_dir, file_stem + '_plddt.png')

            # Get chain lengths.
            Ls = get_chain_lengths(result)
            
            
            # Plot pAEs.
            pae_fig = plot_pae(result['pae_output'][0], Ls)
            pae_fig.savefig(pae_png)
            
            # Plot pLDDTs.
            plddt_fig = plot_plddt(result['plddt'], Ls)
            plddt_fig.savefig(plddt_png)

        
        
    
