diff --git a/modules_multimer.py b/temp.py
index 4e76d41..1edfd6b 100644
--- a/modules_multimer.py
+++ b/temp.py
@@ -474,23 +474,36 @@ class AlphaFold(hk.Module):
         # Eval mode or tests: use the maximum number of iterations.
         num_iter = c.num_recycle
 
-      def recycle_body(i, x):
-        del i
-        prev, safe_key = x
-        safe_key1, safe_key2 = safe_key.split() if c.resample_msa_in_recycling else safe_key.duplicate()  # pylint: disable=line-too-long
-        ret = apply_network(prev=prev, safe_key=safe_key2)
-        return get_prev(ret), safe_key1
-
-      prev, safe_key = hk.fori_loop(0, num_iter, recycle_body, (prev, safe_key))
+      def pw_dist(a):
+        # Computes the distance between all Ca atoms in a structure
+        a_norm = jnp.square(a).sum(-1)
+        return jnp.sqrt(jnp.abs(a_norm[:,None] + a_norm[None,:] - 2 * a @ a.T))
+        
+      def recycle_body(x):
+        n, tol, prev, safe_key = x
+        if c.resample_msa_in_recycling:
+          safe_key1, safe_key2 = safe_key.split()
+        else:
+          safe_key1, safe_key2 = safe_key.duplicate()
+        prev_ = get_prev(apply_network(prev=prev, safe_key=safe_key2))
+        ca, ca_ = prev['prev_pos'][:, 1, :], prev_['prev_pos'][:, 1, :]
+        # Computes average change in distance of Ca atoms across two structures
+        tol_ = jnp.sqrt(jnp.square(pw_dist(ca) - pw_dist(ca_)).mean())
+        return n+1, tol_, prev_, safe_key1
+
+      recycles, tol, prev, safe_key = hk.while_loop(
+        lambda x: ((x[0] < num_iter) & (x[1] > self.config.recycle_tol)),
+        recycle_body, (0, jnp.inf, prev, safe_key))
     else:
       prev = {}
+      (recycles, tol) = 0, jnp.inf
 
     # Run extra iteration.
     ret = apply_network(prev=prev, safe_key=safe_key)
 
     if not return_representations:
       del ret['representations']
-    return ret
+    return ret, (recycles, tol)
 
 
 class EmbeddingsAndEvoformer(hk.Module):
